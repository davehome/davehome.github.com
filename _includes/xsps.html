<ol>
	<li><a href="xsps">xsps</a></li>
</ol>

<hr />
<pre>

Requirements for build system:


1.	Serializable template metadata:

	*	Atomic read/write for the static metadata of each package template.

	*	ie. pkgname, version, revision, maintainer, descriptions, license,
		rshlibs, and build-deps, etc.

	*	The target language (ie. Lua, C, etc) needs to be able to do this (we
		could use the JSON format or even libconfuse for this).


2.	Dynamic template metadata:

	*	More dynamic stuff, like /how/ to build a package, needs to be done in
		the target language for the build system.

	*	Use the target language equivalent for shell functions like 'cd', 'ln',
		'cp', 'rm', etc -- whenever possible.

	*	popen should only be used when necessary (ie. ./configure, make ..).


3.	Control of the build environment

	*	We want a set of build inputs (template) to produce the same build
		output (binpkg) every single time it is built -- on all of the
		architectures we're building it for.

	*	We don't want undefined build behavior, and no accidentally inherited
		ENV vars.

	*	We don't want unintended build-deps being linked-in to the target pkgs.

	*	I really like the read-only masterdir idea with unionfs. We could also
		check out aufs


4.	Automating builds

	*	We want to be able to automate the building of any package target and
		its dependencies while still keeping (3.) above in-check.

	*	We need to be able to handle when a package has a build-dep with an
		api_bump, to automatically revbump those packages that depend on it,
		and rebuild them.

	*	For rebuilds of revbump'd packages, we need to be able to determine the
		correct order for them to be rebuilt in, for example:

			1. pkgs A, B, C and D depend on libfoo-devel
			2. libfoo-devel receives an api_bump
			3. A, B, C, and D need to be rebuilt, however...
			4. A and C depend on B, and B depends on D
			5. Automated build should build in this order:
				- libfoo-devel, D, B, A, C


5.	Cross compiling

	*	We need to be able to build multiple toolchains with the same codebase.

	*	Using qemu, it would technically be possible to support any combination
		of hosts to targets (within practical reason, rofl)

	*	Each target would be put into the /usr directory as follows:
		- x86_64-unknown-linux-gnu
		- i686-pc-linux-gnu
		- arm-pc-linux-gnu
		- x86_64-w64-mingw32
		- etc...

	*	Then, we could either use the stow/unstow system, or unionfs/aufs to
		provide these to $PREFIX/{bin/lib}, etc

	*	This is primarily to support x86_64/i686 multilib properly, and also
		to help port Void GNU/Linux to other architectures.

	*	Secondarily, it could help us provide userspace cross-compilers for the
		users' development environment(s).


6.	Realtime build status

	*	The auto-build system should have the ability to export realtime
		statistics (of what it is currently building) encapsulated into a build
		"task" or something with some kind of state.  The "state" of a build
		task could reference:
			- Which toolchain are we using? [see (5.) above]
			- What is/are the target package(s) for this 'task'?
			- What are it's dependencies?
			- Which pkg/dep is currently being built?
			- Is this a new version/revision or an update due to an api bump?
			- Simple math that can tell us:
				(pkg_building/pkgs_total)*100 [percentage] for this task

	*	This build-state metadata could be encoded in JSON.

	*	This state info can then be provided to 3rd-party clients like a
		fastcgi program (through a local or remote socket) running in a web
		server which can serve an interactive interface to analyze the
		currently building task(s) and/or help us review the logs of previously
		built tasks.

	*	Another example of a 3rd-party client would be an ncurses app which
		provides a similar interface -- or even a simple IRC bot.

	*	These 3rd-party apps should also be able to send signals to the build
		system to [force-](re)start/pause/stop any build task.


7.	Whole system specification

	*	It would also be desirable to be able to easily specify the defaults
		in many areas, such as:
			- Which toolchain are we primarily using? [see (5.) above]
			- Which C library are we using (glibc, eglibc, ulibc, newlib)?
			- Which primary compiler(s) are we using? (gcc, clang)?
			- And others...

	*	We should also be able to swap-out distribution-specific packages like:
			- base-files, base-system, kernel, etc
			- These should be replaceable with comparable ones provided by the
				one building the distribution.

	*	Configuration files for these kinds of things should also be
		serializable, to help with writing separate GUI configuration frontends


8.	Parallel building

	*	Like 'fastbulk', the auto-build system should be able to multiplex
		tasks which are not interdependent on eachother into seperate
		threads; and, perhaps even distribute the running of those threads on
		seperate computers. (This not that high of a priority, though.)


9.	In light of the above, the infrastructure of this build system needs to be
	able to handle this stuff, and handle it fast.. which is the whole reason
	we have to move away from shell script in the first place.

	*	So, the first things we have to decide before designing this thing are:

		1. What language are we going to write this in (C, ObjC, C++, Lua, etc)?
		2. What will be the data serialzation format (JSON, libconfuse, plist)?
		3. How easy/hard is it going to be to re-use existing template data?
		4. How are we going to handle:
			- The multiple-toolchain thing?
			- The auto-build process?
			- Parallel building?
			- Build status?
			- Everything in a distribution-agnostic way?


10.	Regardless of the decisions made, and regardless of how the above is
	eventually implemented, it would be a very good idea to try and describe
	the design of this system in some 'specification':

	1.	To help others contribute to the implementation/maintenance process
	2.	To reduce ambiguities and misunderstandings of how the system works
	3.	To keep any separate re-implementation(s) compatibile with the others
	4.	To help with documenting implementations

	*	This 'specification' could be:
		- Based upon this document or something else
		- Versioned and kept on a wiki




// === Examples in JSON for (7.) ===

System = {
	name: "Void",
	xbps: "0.12.1",
	toolchain: {
		target: "x86_64-unknown-linux-gnu",
		libc: "eglibc",
		cc: "gcc",
		multilib: true
	},
	alternatives: {
		files: "base-files",
		system: "base-system",
		kernel: "linux"
	}
}

// Or....

System = {
	name: "VoidLive",
	xbps: "0.12.1",
	toolchain: {
		target: "x86_64-unknown-linux-gnu",
		libc: "ulibc",
		cc: "gcc",
		multilib: false
	},
	alternatives: {
		files: "base-files-live",
		system: "base-system-live",
		kernel: "linux-live"
	}
}

// Or....

System = {
	name: "AndroidXYZ",
	xbps: "0.12.1",
	toolchain: {
		target: "arm-pc-linux-gnu",
		libc: "newlib",
		cc: "gcc",
		multilib: false
	},
	alternatives: {
		files: "base-files-android",
		system: "base-system-android",
		kernel: "linux-android"
	}
}

// Or....

System = {
	name: "Foo",
	xbps: "0.12.1",
	toolchain: {
		target: "i686-pc-linux-gnu",
		libc: "glibc",
		cc: "clang",
		multilib: true
	},
	alternatives: {
		files: "base-files-foo",
		system: "base-system-foo",
		kernel: "linux-foo"
	}
}
</pre>
